# django基本操作
### 启动django项目
1. 创建django项目
  django-admin startproject my_django1
2. 运行django项目
  python manage.py runserver 127.0.0.1:8000 #默认8000端口
3. 模板配置
```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, "template")],  # template文件夹位置
        'APP_DIRS': True, #会在当前的app中寻找，没有就去其他的app中找
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```
4. 静态文件配置
```python
STATIC_URL = '/static/'  # HTML中使用的静态文件夹前缀
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, "static"),  # 静态文件存放位置
]
```

### django基础必知必会三件套
#### from django.shortcuts import HttpResponse, render, redirect

HttpResponse
>返回一个字符串给浏览器
>return HttpResponse("OK")

render
>返回一个渲染的html文件和一个保存具体数值的字符串给浏览器
>return render(request, "index.html", {"name": "alex", "hobby": ["烫头", "泡吧"]})

redirect
> 表示要跳转的url
> return redirect("www.baidu.com")



### django框架
#### MTV
django框架的设计模式，分成三个部分来降低各个部分之间的耦合性，即Model(模型)、Template(模板)、View(视图)

Model
>负责业务对象与数据库的对象(ORM)

Template
>负责将页面展示给用户

View
>负责业务逻辑，并在其中调用Model和Template

此外，django还有一个urls分发器，它主要是将一个个的url的页面请求发送给不同的view处理，view再调用相应的Model和Template

![1b74565e.png](:storage/7482f07e-34eb-4645-934c-37af32e2292b/1b74565e.png)

#### MVC
MVC(Model View Controller),是软件工程中的一种软件架构模式，把软件系统分为三个基本部分:模型(Model)、视图(View)、控制器(Controller),具有耦合性低、重用性高、生命周期成本低等优点。
![048d9d81.png](:storage/7482f07e-34eb-4645-934c-37af32e2292b/048d9d81.png)



#### 创建app
1. 命令行创建
  python manage.py startapp app01
2. 将创建好的app在setting.py中的INSTALLED_APPS中注册


### 路由系统
#### from djngo.conf.urls import url, include
urlpatterns = [
     url(正则表达式, views视图函数，参数，别名),]
     
注意事项
>1. urlpatterns中的元素按照书写顺写从上往下逐一匹配正则表达式，一旦匹配成功则不再继续。
>2. 若要从url中捕获一个值，只需要在它外面加一个圆括号，分组匹配
>3. 不需要添加一个前导的反斜杠
>4. 每个正则表达式前面的r是可选的，但是建议加上

补充说明
>是否开启url访问地址后面并不为/跳转至带有/的路径的配置项
>APPEND_SLASH = Ture
>
#### 分组命名匹配
```python
urlpatterns = [
    url(r'^articles/2003/$', views.special_case_2003),
    url(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),
    url(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/$', views.month_archive),
    url(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/(?P<day>[0-9]{2})/$', views.article_detail),
```
views中的函数调用
>views.month_archive(request, year="2017", month="12")
>
**捕获的参数永远是字符换类型**

##### 视图函数中指定默认值
url中
>url(r'enrollment_list/(?P<customer_id>\d+)/', views.enrollment_list, name='enrollment_list'),  # 报名表
>
views中
>def enrollment_list(request, customer_id=0):pass
>

##### 命名url与反向解析
url中
>url(r'^home', views.home, name='home'),  # 给我的url匹配模式起名为 home
url(r'^index/(\d*)', views.index, name='index'),  # 给我的url匹配模式起名为index

模板里引用
>{% url 'home' %}

views函数中引用
>from django.urls import reverse
>reverse("index", args=("2018",))


##### 命令空间
```python
urlpatterns = [
    url(r'^app01/', include('app01.urls', namespace='app01')),
    url(r'^app02/', include('app02.urls', namespace='app02')),
]
```

模板中使用

>{% url 'app01:detail' pk=12 pp=99 %}

views函数中使用
>redirect(reverse(reverse('app01:detail', kwargs={'pk':11})))

### 视图系统
#### FBV
>基于函数的视图系统
```python
def add_class(request):
    if request.method == "POST":
        class_name = request.POST.get("class_name")
        models.Classes.objects.create(name=class_name)
        return redirect("/class_list/")
    return render(request, "add_class.html")
```
#### CBV
>基于类的视图系统
>使用CBV时要注意，请求过来后会先执行dispatch()这个方法，如果需要批量对具体的请求处理方法，如get，post等做一些操作的时候，这里我们可以手动改写dispatch方法，这个dispatch方法就和在FBV上加装饰器的效果一样。
```python
from django.views import View
from django.utils.decorators import method_decorator

@method_decorator(wrapper, name="get")
class AddClass(View):
    @method_decorator(wrapper)
    def dispatch(self, request, *args, **kwargs):
        print('before')
        obj = super(Login,self).dispatch(request, *args, **kwargs)
        print('after')
        return obj
    
    @method_decorator(wrapper)
    def get(self, request):
        return render(request, "add_class.html")
      
    @method_decorator(wrapper)
    def post(self, request):
        class_name = request.POST.get("class_name")
        models.Classes.objects.create(name=class_name)
        return redirect("/class_list/")
```
给cbv加装饰器有三种方式：
1. 在函数上通过@method_decorator(wrapper)添加
2. 在display上通过@method_decorator(wrapper)添加
3. 在类上通过@method_decorator(wrapper, name="get")添加

注意
>CSRF Token相关装饰器在CBV只能加到dispatch方法上
>csrf_protect，为当前函数强制设置防跨站请求伪造功能，即便settings中没有设置全局中间件。
csrf_exempt，取消当前函数防跨站请求伪造功能，即便settings中设置了全局中间
```python
from django.views.decorators.csrf import csrf_exempt, csrf_protect


class HomeView(View):

    @method_decorator(csrf_exempt)
    def dispatch(self, request, *args, **kwargs):
        return super(HomeView, self).dispatch(request, *args, **kwargs)

    def get(self, request):
        return render(request, "home.html")

    def post(self, request):
        print("Home View POST method...")
        return redirect("/index/")

```




