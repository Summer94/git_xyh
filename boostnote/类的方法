### 类的方法
#### 类的反射
>hasattr(obj,name) 判断对象中有没有name这个字符串或者属性
getattr(obj,name) 获取对象中的name
setattr(obj,name,summer) 添加，修改对象的属性值
```python
class Foo:
    def __init__(self,name):
        self.name = name

p = Foo("summer")
print(hasattr(p,"name"))  #判断对象中有没有name这个字符串属性
print(getattr(p,"name")) #获取对象中的name,没有则报错
setattr(p,"age",18) #添加，修改对象的属性值
print(p.__dict__) #{'name': 'summer', 'age': 18}
```
#### `__getattr__\__setattr__\__delattr__`
>__getattr__只有在使用点调用属性且属性不存在的时候才会触发
>__setattr__使用点添加/修改属性会触发它的执行
>__delattr__使用点删除属性的时候会触发
```python
class Foo:
    def __init__(self,name):
        self.name = name

    def __getattr__(self, item):
        print("没有item这个属性就会执行")

    def __setattr__(self, key, value):
        print("通过obj.key执行")
        self.__dict__[key] = value  #没有这个赋值操作，永远都无法赋值

    def __delattr__(self, item):
        print("通过del obj.item执行")
        self.__dict__.pop(item) #实际的删除操作

p = Foo("summer")
p.name  #通过obj.key执行
p.age = 18 #通过obj.key执行
print(p.__dict__) #{'name': 'summer', 'age': 18}
del p.age #通过del obj.item执行
p.sex #没有item这个属性就会执行
```
####  `__setitem__\__getitem\__delitem__`
>**使用字符串调用属性时触发**
```python
class Foo:
    def __init__(self,name):
        self.name = name

    def __getattr__(self, item):
        print("没有item这个属性就会执行")

    def __setattr__(self, key, value):
        print("通过obj.key执行")
        self.__dict__[key] = value  #没有这个赋值操作，永远都无法赋值

    def __delattr__(self, item):
        print("通过del obj.item执行")
        self.__dict__.pop(item) #实际的删除操作

    def __getitem__(self, item):
        print("使用obj[item]时执行")
        return self.__dict__[item]

    def __setitem__(self, key, value):
        print("使用obj[key]是执行")
        self.__dict__[key] = value

    def __delitem__(self, key):
        print("del obj[key]是执行")
        self.__dict__.pop(key)



p = Foo("summer")
p["name"]  #使用obj[item]时执行
p["age"] = 18  #使用obj[key]是执行
print(p.__dict__)  #{'name': 'summer', 'age': 18}
del p["age"] #del obj[key]是执行
```
